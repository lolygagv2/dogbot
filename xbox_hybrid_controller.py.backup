#!/usr/bin/env python3
"""
Hybrid Xbox Controller for DogBot
- Direct motor control for low latency movement
- API calls for other features (photos, sounds, treats)
"""

import struct
import time
import os
import sys
import logging
import requests
import signal
import threading
from threading import Thread, Event, Timer
from dataclasses import dataclass
from typing import Optional, Tuple

# Add project root to path for direct imports
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Direct hardware import for motors and servos
try:
    from core.hardware.motor_controller import MotorController
    MOTOR_DIRECT = True
    motor_controller = MotorController()
    logger = logging.getLogger('XboxHybrid')
    logger.info("Direct motor control initialized")
except ImportError:
    # Fallback to gpioset if PWM not available
    try:
        from core.hardware.motor_controller_gpioset import MotorController
        MOTOR_DIRECT = True
        motor_controller = MotorController()
        logger = logging.getLogger('XboxHybrid')
        logger.info("Direct motor control initialized (gpioset mode)")
    except ImportError:
        MOTOR_DIRECT = False
        motor_controller = None
        logger = logging.getLogger('XboxHybrid')
        logger.warning("No direct motor control available, will use API")

# Try to import servo controller for direct camera control
try:
    from core.hardware.servo_controller import ServoController
    servo_controller = ServoController()
    SERVO_DIRECT = True
    logger.info("Direct servo control initialized")
except ImportError:
    servo_controller = None
    SERVO_DIRECT = False
    logger.warning("No direct servo control available, will use API")

# Try to connect to event bus for mode management
event_bus = None
try:
    from core.bus import get_bus, publish_system_event
    event_bus = get_bus()
    logger.info("Connected to event bus for mode management")
except ImportError:
    logger.info("Event bus not available, running standalone")

logging.basicConfig(level=logging.INFO)

def notify_manual_input():
    """Notify the system that manual input occurred"""
    if event_bus:
        try:
            publish_system_event('manual_input_detected', {
                'timestamp': time.time(),
                'source': 'xbox_controller'
            }, 'xbox_hybrid_controller')
            logger.info("Manual input event published - should switch to MANUAL mode")
        except Exception as e:
            logger.warning(f"Failed to notify manual input: {e}")
    else:
        logger.warning("Event bus not available - manual mode switching disabled")

@dataclass
class ControllerState:
    """Track controller button/axis states"""
    left_x: float = 0.0
    left_y: float = 0.0
    right_x: float = 0.0
    right_y: float = 0.0
    left_trigger: float = 0.0
    right_trigger: float = 0.0
    a_button: bool = False
    b_button: bool = False
    x_button: bool = False
    y_button: bool = False
    left_bumper: bool = False
    right_bumper: bool = False
    dpad_up: bool = False
    dpad_down: bool = False
    dpad_left: bool = False
    dpad_right: bool = False

    # Track motor state to avoid redundant commands
    last_left_speed: int = 0
    last_right_speed: int = 0
    motors_stopped: bool = True


class XboxHybridController:
    """Hybrid Xbox controller - direct motors, API for rest"""

    # API configuration
    API_BASE_URL = "http://localhost:8000"

    # Controller configuration
    DEADZONE = 0.15
    TRIGGER_DEADZONE = 0.1
    MAX_SPEED = 100
    TURN_SPEED_FACTOR = 0.6

    # Sound track numbers on SD card (D-pad navigation)
    # These map to the actual audio files in /talks/ folder
    SOUND_TRACKS = [
        (1, "Scooby Intro"),      # 0001.mp3
        (3, "Elsa"),               # 0003.mp3
        (4, "Bezik"),              # 0004.mp3
        (8, "Good Dog"),           # 0008.mp3 - GOOD
        (13, "Treat"),             # 0013.mp3 - Treat
        (15, "Sit"),               # 0015.mp3
        (16, "Spin"),              # 0016.mp3
        (17, "Stay")               # 0017.mp3
    ]

    # Y button alternates between these sounds (using file paths)
    # Index 0 = Good (even presses), Index 1 = Treat (odd presses)
    REWARD_SOUNDS = [
        ("/talks/0008.mp3", "Good Dog"),    # Index 0 - even presses (2nd, 4th, 6th...)
        ("/talks/0013.mp3", "Treat")        # Index 1 - odd presses (1st, 3rd, 5th...)
    ]

    def __init__(self, device_path: str = '/dev/input/js0'):
        self.device_path = device_path
        self.device = None
        self.running = False
        self.state = ControllerState()
        self.stop_event = Event()

        # Sound navigation
        self.current_sound_index = 0
        # Y button: 0=Treat (first press), 1=Good (second press), etc.

        # Photo capture cooldown
        self.last_photo_time = 0
        self.photo_cooldown = 2.0  # seconds

        # Camera control timer for smooth movement
        self.camera_timer = None
        self.camera_update_interval = 0.05  # 20Hz update rate for smooth movement

        # LED state tracking
        self.led_enabled = False
        self.current_led_mode = 0
        # Use the actual LED modes the API supports (matching LEDMode enum)
        self.led_modes = [
            "off",              # Turn off NeoPixels
            "idle",             # Default idle mode
            "searching",        # Searching for dogs
            "dog_detected",     # Dog detected
            "treat_launching",  # Dispensing treat
            "error",            # Error/warning
            "charging",         # Charging mode
            "manual_rc"         # Manual RC mode
        ]

        # API session for non-motor functions
        self.session = requests.Session()
        self.session.headers.update({'Content-Type': 'application/json'})

        logger.info(f"Xbox Hybrid Controller initialized for {device_path}")
        logger.info(f"Motor control: {'DIRECT' if MOTOR_DIRECT else 'API'}")
        logger.info(f"API endpoint: {self.API_BASE_URL}")

        # Preload audio system to prevent first-time delay
        self._preload_audio_system()

    def _preload_audio_system(self):
        """Preload audio system to prevent first-time delay"""
        try:
            logger.info("Preloading audio system...")
            # Make a quick status check to initialize the audio controller
            result = self.api_request('GET', '/audio/status')
            if result:
                logger.info("Audio system preloaded successfully")
            else:
                logger.warning("Audio system preload failed - first audio may be delayed")
        except Exception as e:
            logger.warning(f"Audio preload error: {e} - first audio may be delayed")

    def api_request(self, method: str, endpoint: str, data: Optional[dict] = None) -> Optional[dict]:
        """Make API request with error handling"""
        url = f"{self.API_BASE_URL}{endpoint}"
        try:
            # Longer timeout for audio commands since DFPlayer is slow
            timeout = 10.0 if 'audio' in endpoint else 2.0

            if method == 'GET':
                response = self.session.get(url, timeout=timeout)
            elif method == 'POST':
                response = self.session.post(url, json=data, timeout=timeout)
            else:
                logger.error(f"Unsupported method: {method}")
                return None

            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            logger.error(f"API request failed: {endpoint} - {e}")
            return None

    def connect(self) -> bool:
        """Connect to the Xbox controller"""
        try:
            # Check if API is available for other features
            health = self.api_request('GET', '/health')
            if health:
                logger.info(f"API health check: {health}")
            else:
                logger.warning("API server not responding - only motor control will work")

            # Open the joystick device
            self.device = open(self.device_path, 'rb')
            logger.info(f"Connected to Xbox controller at {self.device_path}")

            # Motors are initialized in __init__, just log status
            if MOTOR_DIRECT and motor_controller:
                if motor_controller.is_initialized():
                    logger.info("Direct motor control ready")
                else:
                    logger.warning("Motor controller not properly initialized")

            return True

        except FileNotFoundError:
            logger.error(f"Controller not found at {self.device_path}")
            return False
        except Exception as e:
            logger.error(f"Failed to connect: {e}")
            return False

    def read_event(self) -> Optional[Tuple]:
        """Read a single joystick event"""
        try:
            event_data = self.device.read(8)
            if event_data:
                # Parse as signed integers (fixed the issue)
                timestamp, value, event_type, number = struct.unpack('IhBB', event_data)
                return (timestamp, value, event_type, number)
        except Exception as e:
            logger.error(f"Error reading event: {e}")
        return None

    def process_axis(self, number: int, value: int):
        """Process axis movement"""

        # DEBUG: Log axis events to catch X button if sent as axis
        if abs(value) > 10000:  # Significant axis movement
            with open('/tmp/xbox_axis_debug.txt', 'a') as f:
                f.write(f"Axis {number} = {value}\n")

        # Normalize to -1.0 to 1.0
        normalized = value / 32767.0

        # Removed excessive debug logging

        # Apply deadzone
        if abs(normalized) < self.DEADZONE:
            normalized = 0.0

        # Update state based on axis
        if number == 0:  # Left stick X
            self.state.left_x = normalized
            # Notify manual input only for movement controls (left stick + right trigger)
            if abs(normalized) > self.DEADZONE:
                notify_manual_input()
        elif number == 1:  # Left stick Y (inverted for forward)
            self.state.left_y = -normalized
            # Notify manual input only for movement controls (left stick + right trigger)
            if abs(normalized) > self.DEADZONE:
                notify_manual_input()
        elif number == 3:  # Right stick X (camera pan)
            self.state.right_x = normalized
            # Camera controls do NOT trigger manual input notifications
            if SERVO_DIRECT and abs(normalized) > 0.2:  # Higher threshold to prevent drift
                # Adjust center to balance left/right: you get 65Â° right, 35Â° left
                # So center should shift left to balance: from 105 to 125
                # RIGHT stick right = camera RIGHT = LOWER angle
                # RIGHT stick left = camera LEFT = HIGHER angle
                pan_angle = 125 - (normalized * 95)  # 30-220 degree range, centered at 125 (balanced)
                servo_controller.set_camera_pan(pan_angle)
        elif number == 4:  # Right stick Y (camera tilt)
            self.state.right_y = -normalized
            # Camera controls do NOT trigger manual input notifications
            if SERVO_DIRECT and abs(normalized) > 0.2:  # Higher threshold to prevent drift
                # Increase UP range even more: you want 70Â° from horizon (25Â° more than current 45Â°)
                # Keep DOWN working, extend UP significantly
                tilt_angle = 55 - (normalized * 75)  # -20 to 130 degree range (much more UP movement)
                servo_controller.set_camera_pitch(tilt_angle)
        elif number == 2:  # Left trigger - Cycle LED modes
            self.state.left_trigger = (value + 32767) / 65534.0

            # Initialize the flag if it doesn't exist
            if not hasattr(self, '_lt_pressed'):
                self._lt_pressed = False

            # Trigger LED mode change when pulled more than 30% (lowered threshold)
            if self.state.left_trigger > 0.3 and not self._lt_pressed:
                self._lt_pressed = True
                logger.info(f"Left Trigger pulled ({self.state.left_trigger:.2f}) - cycling LED mode")
                self.cycle_led_mode()
            elif self.state.left_trigger < 0.1:  # Released completely
                if self._lt_pressed:
                    logger.debug(f"Left Trigger released ({self.state.left_trigger:.2f})")
                self._lt_pressed = False
        elif number == 5:  # Right trigger
            self.state.right_trigger = (value + 32767) / 65534.0

        # Update motor control for left stick
        if number in [0, 1]:
            self.update_motor_control()

    def process_button(self, number: int, pressed: bool):
        """Process button press/release"""

        # DEBUG: Log ALL button presses to debug X button issue
        if pressed:
            logger.info(f"BUTTON DEBUG: Button {number} pressed")
            # Write to file for debugging
            with open('/tmp/xbox_button_debug.txt', 'a') as f:
                f.write(f"Button {number} pressed\n")
            notify_manual_input()

        if number == 0:  # A button
            self.state.a_button = pressed
            if pressed:
                logger.info("A button: Emergency stop")
                self.emergency_stop()

        elif number == 1:  # B button
            self.state.b_button = pressed
            if pressed:
                logger.info("B button: Stop motors")
                self.stop_motors()

        elif number == 2:  # X button - Toggle LED
            # DEBUG: Add debug here to see if this condition is reached
            with open('/tmp/xbox_button_debug.txt', 'a') as f:
                f.write(f"X button handler reached! pressed={pressed}\n")

            self.state.x_button = pressed
            if pressed:
                logger.warning("ðŸŽ® X BUTTON PRESSED! Calling toggle_led()")
                print("ðŸŽ® X BUTTON PRESSED! Calling toggle_led()")
                with open('/tmp/xbox_button_debug.txt', 'a') as f:
                    f.write("About to call toggle_led()\n")
                self.toggle_led()

        # DEBUGGING: Check if X button is being sent as a different number
        if pressed and number not in [0, 1, 2, 3, 4, 5]:
            logger.warning(f"ðŸŽ® UNKNOWN BUTTON {number} pressed - might be X button!")
            print(f"ðŸŽ® UNKNOWN BUTTON {number} pressed - might be X button!")
            if number == 6 or number == 7:  # Common X button alternatives
                logger.warning("ðŸŽ® Treating as X button!")
                print("ðŸŽ® Treating as X button!")
                self.toggle_led()

        elif number == 3:  # Y button - Toggle Good/Treat
            self.state.y_button = pressed
            if pressed:
                self.play_reward_sound()

        elif number == 4:  # Left bumper (LB) - Dispense treat
            self.state.left_bumper = pressed
            if pressed:
                self.dispense_treat()

        elif number == 5:  # Right bumper (RB) - Take photo
            self.state.right_bumper = pressed
            if pressed:
                self.take_photo()

    def process_dpad(self, number: int, value: int):
        """Process D-pad input for audio control"""

        # Notify manual input for any D-pad press
        if value != 0:
            notify_manual_input()

        if number == 6:  # D-pad X axis
            self.state.dpad_left = (value < 0)
            self.state.dpad_right = (value > 0)

            if value < 0:  # Left - Previous track
                self.current_sound_index = (self.current_sound_index - 1) % len(self.SOUND_TRACKS)
                track_num, track_name = self.SOUND_TRACKS[self.current_sound_index]
                logger.info(f"Selected: {track_name}")
            elif value > 0:  # Right - Next track
                self.current_sound_index = (self.current_sound_index + 1) % len(self.SOUND_TRACKS)
                track_num, track_name = self.SOUND_TRACKS[self.current_sound_index]
                logger.info(f"Selected: {track_name}")

        elif number == 7:  # D-pad Y axis
            self.state.dpad_up = (value < 0)
            self.state.dpad_down = (value > 0)

            if value < 0:  # Up - Pause/Resume
                logger.info("D-pad up: Pause/Resume")
                self.api_request('POST', '/audio/pause')
            elif value > 0:  # Down - Play selected track
                track_num, track_name = self.SOUND_TRACKS[self.current_sound_index]
                logger.info(f"D-pad down: Play {track_name}")
                self.play_sound_effect()

    def update_motor_control(self):
        """Update motor speeds based on joystick input"""
        # Variable speed based on trigger
        speed_multiplier = 0.3 + (self.state.right_trigger * 0.7)

        # Calculate motor speeds from left stick
        forward = self.state.left_y * self.MAX_SPEED * speed_multiplier
        turn = self.state.left_x * self.MAX_SPEED * self.TURN_SPEED_FACTOR * speed_multiplier

        left_speed = int(forward + turn)
        right_speed = int(forward - turn)

        # Clamp to valid range
        left_speed = max(-self.MAX_SPEED, min(self.MAX_SPEED, left_speed))
        right_speed = max(-self.MAX_SPEED, min(self.MAX_SPEED, right_speed))

        # Only send if changed significantly
        if (abs(left_speed - self.state.last_left_speed) > 5 or
            abs(right_speed - self.state.last_right_speed) > 5 or
            (left_speed == 0 and right_speed == 0 and not self.state.motors_stopped)):

            self.set_motor_speeds(left_speed, right_speed)
            self.state.last_left_speed = left_speed
            self.state.last_right_speed = right_speed
            self.state.motors_stopped = (left_speed == 0 and right_speed == 0)

    def set_motor_speeds(self, left: int, right: int):
        """Set motor speeds - DIRECT hardware control for low latency"""
        if MOTOR_DIRECT and motor_controller:
            # Direct hardware control - minimal latency
            try:
                if left == 0 and right == 0:
                    motor_controller.emergency_stop()
                    logger.debug("Motors stopped (direct)")
                else:
                    # Set individual motor speeds directly
                    # Motor A (left), Motor B (right)
                    left_dir = 'forward' if left >= 0 else 'backward'
                    right_dir = 'forward' if right >= 0 else 'backward'
                    left_speed = abs(left)
                    right_speed = abs(right)

                    motor_controller.set_motor_speed('A', left_speed, left_dir)
                    motor_controller.set_motor_speed('B', right_speed, right_dir)
                    logger.debug(f"Motors (direct): L={left:4d}, R={right:4d}")
            except Exception as e:
                logger.error(f"Direct motor control error: {e}")
                # Fallback to API
                self._set_motor_speeds_api(left, right)
        else:
            # Use API if no direct control
            self._set_motor_speeds_api(left, right)

    def _set_motor_speeds_api(self, left: int, right: int):
        """Fallback API motor control"""
        data = {
            "left_speed": left,
            "right_speed": right
        }
        result = self.api_request('POST', '/motor/control', data)
        if result and result.get('success'):
            if left != 0 or right != 0:
                logger.debug(f"Motors (API): L={left:4d}, R={right:4d}")

    def stop_motors(self):
        """Stop all motors"""
        if MOTOR_DIRECT and motor_controller:
            try:
                motor_controller.emergency_stop()
                logger.info("Motors stopped (direct)")
                self.state.motors_stopped = True
                return
            except Exception as e:
                logger.error(f"Direct motor stop error: {e}")

        # Fallback to API
        result = self.api_request('POST', '/motor/stop', {"reason": "controller_stop"})
        if result:
            logger.info("Motors stopped (API)")
        self.state.motors_stopped = True

    def emergency_stop(self):
        """Emergency stop - try both direct and API"""
        logger.warning("EMERGENCY STOP activated")

        # Try direct first for fastest response
        if MOTOR_DIRECT and motor_controller:
            try:
                motor_controller.emergency_stop()
            except:
                pass

        # Also send via API to ensure all systems stop
        self.api_request('POST', '/motor/stop', {"reason": "emergency"})
        self.state.motors_stopped = True

    def control_camera_pan(self, stick_value):
        """Simple camera pan - direct position mapping"""
        # Rate limiting
        if not hasattr(self, '_last_pan_command'):
            self._last_pan_command = 0

        import time
        now = time.time()
        if now - self._last_pan_command < 0.1:  # 100ms rate limit
            return

        # Only move if stick is pushed significantly
        if abs(stick_value) > 0.4:
            # Map stick directly to pan position
            # stick_value: -1 (left) to +1 (right)
            # pan range: 10 to 170 degrees
            center = 90
            range_degrees = 80  # 80 degrees each way

            target_pan = center + (stick_value * range_degrees)
            target_pan = max(10, min(170, int(target_pan)))

            print(f"ðŸ“¹ PAN: stick={stick_value:.2f} â†’ {target_pan}Â°")

            try:
                result = self.api_request('POST', '/camera/pantilt', {"pan": target_pan})
                self._last_pan_command = now
            except Exception as e:
                print(f"ðŸ“¹ PAN error: {e}")

    def control_camera_tilt(self, stick_value):
        """Simple camera tilt - direct position mapping"""
        # Rate limiting
        if not hasattr(self, '_last_tilt_command'):
            self._last_tilt_command = 0

        import time
        now = time.time()
        if now - self._last_tilt_command < 0.1:  # 100ms rate limit
            return

        # Only move if stick is pushed significantly
        if abs(stick_value) > 0.4:
            # Map stick directly to tilt position
            # stick_value: -1 (up) to +1 (down)
            # tilt range: 30 to 150 degrees
            center = 90
            range_degrees = 60  # 60 degrees each way

            # Invert stick so UP = UP camera movement
            target_tilt = center - (stick_value * range_degrees)
            target_tilt = max(30, min(150, int(target_tilt)))

            print(f"ðŸ“¹ TILT: stick={stick_value:.2f} â†’ {target_tilt}Â°")

            try:
                result = self.api_request('POST', '/camera/pantilt', {"tilt": target_tilt})
                self._last_tilt_command = now
            except Exception as e:
                print(f"ðŸ“¹ TILT error: {e}")

    def dispense_treat(self):
        """Dispense treat via API"""
        logger.info("LB pressed: Dispensing treat")
        data = {
            "dog_id": "xbox_test",
            "reason": "manual_xbox",
            "count": 1
        }
        result = self.api_request('POST', '/treat/dispense', data)
        if result and result.get('success'):
            logger.info("Treat dispensed!")

    def take_photo(self):
        """Take photo via API"""
        current_time = time.time()
        if current_time - self.last_photo_time < self.photo_cooldown:
            return

        logger.info("RB pressed: Taking photo")
        self.last_photo_time = current_time

        result = self.api_request('POST', '/camera/photo')
        if result and result.get('success'):
            logger.info(f"Photo saved: {result.get('filename')} ({result.get('resolution')})")

    def play_sound_effect(self):
        """Play sound effect via API (D-pad selected)"""
        track_num, track_name = self.SOUND_TRACKS[self.current_sound_index]
        logger.info(f"Playing {track_name} (track #{track_num})")

        # Play by track number directly - more reliable
        data = {"number": track_num}
        result = self.api_request('POST', '/audio/play/number', data)
        if result and result.get('success'):
            logger.info(f"Now playing: {track_name}")
        else:
            logger.error(f"Failed to play {track_name}")

    def play_reward_sound(self):
        """Play reward sound - always consistent pattern: Treat, Good, Treat, Good..."""
        # Determine which sound based on press count (no memory)
        # Odd presses (1st, 3rd, 5th...) = Treat
        # Even presses (2nd, 4th, 6th...) = Good
        if not hasattr(self, '_y_press_count'):
            self._y_press_count = 0

        self._y_press_count += 1

        # Odd press = Treat (index 1), Even press = Good (index 0)
        sound_index = 1 if (self._y_press_count % 2 == 1) else 0
        filepath, track_name = self.REWARD_SOUNDS[sound_index]

        logger.info(f"Y button press #{self._y_press_count}: Playing {track_name}")

        # Play the sound by filepath
        data = {"filepath": filepath}
        result = self.api_request('POST', '/audio/play/file', data)
        if result and result.get('success'):
            logger.info(f"Playing: {track_name} ({filepath})")
        else:
            logger.error(f"Failed to play {track_name}")

    def toggle_led(self):
        """Toggle blue LED on/off (X button)"""
        try:
            with open('/tmp/xbox_button_debug.txt', 'a') as f:
                f.write("toggle_led() STARTED\n")

            logger.warning("ðŸ”µ toggle_led() function called!")
            print("ðŸ”µ toggle_led() function called!")

            self.led_enabled = not self.led_enabled

            with open('/tmp/xbox_button_debug.txt', 'a') as f:
                f.write(f"led_enabled = {self.led_enabled}\n")

            if self.led_enabled:
                # Turn on blue LED
                with open('/tmp/xbox_button_debug.txt', 'a') as f:
                    f.write("Calling /leds/blue/on\n")
                logger.warning("ðŸ”µ Calling API: /leds/blue/on")
                print("ðŸ”µ Calling API: /leds/blue/on")
                result = self.api_request('POST', '/leds/blue/on')
                with open('/tmp/xbox_button_debug.txt', 'a') as f:
                    f.write(f"API result: {result}\n")
                logger.warning(f"ðŸ”µ API result: {result}")
                print(f"ðŸ”µ API result: {result}")
                if result and result.get('success'):
                    logger.info("Blue LED turned on")
            else:
                # Turn off blue LED
                with open('/tmp/xbox_button_debug.txt', 'a') as f:
                    f.write("Calling /leds/blue/off\n")
                logger.warning("ðŸ”µ Calling API: /leds/blue/off")
                print("ðŸ”µ Calling API: /leds/blue/off")
                result = self.api_request('POST', '/leds/blue/off')
                with open('/tmp/xbox_button_debug.txt', 'a') as f:
                    f.write(f"API result: {result}\n")
                logger.warning(f"ðŸ”µ API result: {result}")
                print(f"ðŸ”µ API result: {result}")
                if result and result.get('success'):
                    logger.info("Blue LED turned off")

            with open('/tmp/xbox_button_debug.txt', 'a') as f:
                f.write("toggle_led() COMPLETED\n")

        except Exception as e:
            with open('/tmp/xbox_button_debug.txt', 'a') as f:
                f.write(f"toggle_led() ERROR: {e}\n")
            logger.error(f"toggle_led() error: {e}")

    def cycle_led_mode(self):
        """Cycle through NeoPixel LED modes (Left Trigger)"""
        self.current_led_mode = (self.current_led_mode + 1) % len(self.led_modes)
        mode = self.led_modes[self.current_led_mode]

        logger.info(f"Left Trigger: NeoPixel LED mode = {mode}")

        # Apply new NeoPixel mode
        data = {"mode": mode}
        result = self.api_request('POST', '/leds/mode', data)
        if result and result.get('success'):
            logger.info(f"NeoPixel LEDs set to {mode} mode")
        else:
            logger.error(f"Failed to set NeoPixel mode to {mode}")

    # Removed update_camera_smooth - camera now controlled directly on joystick events

    def run(self):
        """Main control loop"""
        if not self.connect():
            logger.error("Failed to connect to controller")
            return

        self.running = True
        logger.info("Xbox Hybrid controller ready!")
        logger.info("=== UPDATED CONTROLS ===")
        logger.info("Movement: Left stick + RT for speed control")
        logger.info("Camera: Right stick (smooth pan/tilt)")
        logger.info("A = Emergency Stop, B = Stop Motors")
        logger.info("X = Blue LED On/Off, LT = Cycle NeoPixel LED modes")
        logger.info("Y = Treat/Good sound (alternating: Treat, Good, Treat...)")
        logger.info("LB = Dispense Treat, RB = Take Photo")
        logger.info("D-pad = Audio controls (L/R select, Up pause, Down play)")
        logger.info("=== FIXES APPLIED ===")
        logger.info("- Camera scanning stops when in MANUAL mode")
        logger.info("- X button controls blue LED via /leds/blue/on|off API")
        logger.info("- LT cycles NeoPixel modes via /leds/mode API")
        logger.info("- Manual input detection improved with event bus")

        # Camera control moved to joystick events only - no continuous timer

        try:
            while self.running and not self.stop_event.is_set():
                event = self.read_event()
                if not event:
                    continue

                timestamp, value, event_type, number = event

                # Process based on event type
                if event_type == 0x01:  # Button event
                    pressed = (value == 1)
                    self.process_button(number, pressed)

                elif event_type == 0x02:  # Axis event
                    if number in [6, 7]:  # D-pad
                        self.process_dpad(number, value)
                    else:
                        self.process_axis(number, value)

        except KeyboardInterrupt:
            logger.info("Interrupted by user")
        except Exception as e:
            logger.error(f"Controller error: {e}")
        finally:
            self.cleanup()

    def cleanup(self):
        """Clean up resources"""
        logger.info("Cleaning up...")
        self.running = False

        # Stop camera timer
        if self.camera_timer:
            self.camera_timer.cancel()

        # Stop motors
        self.stop_motors()

        # Clean up motor controller
        if MOTOR_DIRECT and motor_controller:
            try:
                motor_controller.cleanup()
            except:
                pass

        # Close device
        if self.device:
            self.device.close()

        # Close API session
        self.session.close()

        logger.info("Xbox controller disconnected")

    def stop(self):
        """Stop the controller"""
        self.stop_event.set()


def main():
    """Main entry point"""
    # Check for joystick device
    js_device = '/dev/input/js0'
    if not os.path.exists(js_device):
        logger.error(f"No joystick at {js_device}")
        logger.info("Make sure Xbox controller is connected and run:")
        logger.info("  sudo ./fix_xbox_controller.sh")
        return

    controller = XboxHybridController(js_device)

    try:
        controller.run()
    except Exception as e:
        logger.error(f"Controller failed: {e}")
    finally:
        controller.cleanup()


if __name__ == "__main__":
    main()